I've been thinking quite a bit about how to handle events properly and how to sanely write them in pure Zig, and the best way that I think I've come to realize is to do what is generally done in immediate mode GUI libraries, which is handle events during rendering.

The biggest gripe that I have with this is that it can break state that's shared across the application, making things appear inconsistent, even if only for a frame. I've come to terms t that this can be fixed, if we do something like React does where it queues state setting, instead of applying it immediately. This way, we can ensure that the state is consistent throughout the frame, and only updated at the end of the frame.

The syntax for this feels harder to me, but maybe it allows for less use of heap for allocating children, and for an "append to tree" model

on an append-to-tree rendering model the problem is defining children in a way that can be manipulated before layouting

```zig
const std = @import("std");

pub const ButtonProps = struct {
    loading: bool,
};

pub fn Button(props: ButtonProps, arena: std.mem.Allocator) !forbear.Node {
    const eventData = .{ .props = props };
    forbear.div(.{
        .onClick = try forbear..{
            .data = eventData,
            .handler = struct {
                fn handler(data: *const @TypeOf(eventData)) !void {
                    if (data.props.loading) {
                        std.debug.print("Button is loading, click ignored.\n", .{});
                    } else {
                        std.debug.print("Button clicked!\n", .{});
                    }
                }
            }.handler,
        },
        .children = try forbear.Children(.{
        }, arena)
    })
}
```
